<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - effects - ascii</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="../styles.css">
</head>

<body>
<div id="info"><a href="https://threejs.org" target="_blank" >three.js</a> - effects - ascii</div>

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
    {
        "imports":
        {
            "three": "https://unpkg.com/three/build/three.module.js",
            "three-trackballcontrols": "https://unpkg.com/three/examples/jsm/controls/TrackballControls.js",
            "three-gltfloader": "https://unpkg.com/three/examples/jsm/loaders/GLTFLoader.js"
        }
    }
</script>

<script type="module">
    import * as THREE from "three";
    import { AsciiEffect } from "./AsciiEffect.js";
    import { TrackballControls } from "three-trackballcontrols";
    import { GLTFLoader } from "three-gltfloader";

    let camera, controls, scene, renderer, effect;

    let sphere, plane;

    const start = Date.now();

    init();
    animate();

    function init() {

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 7.5;

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0, 0, 0 );

        const pointLight1 = new THREE.PointLight( 0xffffff );
        pointLight1.position.set( 500, 500, 500 );
        scene.add( pointLight1 );

        const pointLight2 = new THREE.PointLight( 0xffffff, 0.25 );
        pointLight2.position.set( - 500, - 500, - 500 );
        scene.add( pointLight2 );


        /* ---------------------------- Setup objects ---------------------------- */
        function loadGLTF(path)
        {
            return new Promise(resolve => {
                new GLTFLoader().load(path, resolve);
            });
        }

        const group = new THREE.Group();
        var spaceStationV, orion;

        const spaceStationVDistance = 10;
        const orionDistance = 4;
        const totalDistance = spaceStationVDistance + orionDistance - 1.7; // Subtracting the distance from the center of SpaceStationV to the hangar

        var orionStartPosition;
        var areModelsLoaded = false;

        // Import models with promises (regular models used for visuals and convex models used for hitboxes)
        let promiseSpaceStationV = loadGLTF('../models/space_station_v/SpaceStationV_Simplified.glb').then(result => { spaceStationV = result.scene; });
        let promiseOrion = loadGLTF('../models/orion/Orion_Simplified_Small.glb').then(result => { orion = result.scene; });

        // Setup the objects in their scenes, once all the models have loaded
        Promise.all([promiseSpaceStationV, promiseOrion]).then(() => {
            // Group visual objects
            group.add(spaceStationV);
            group.add(orion);

            // Rotate groups
            group.rotation.set(0, 12.5*3.14/180, -26.5*3.14/180);

            // Rescale objects (some smaller versions of models are imported and upscaled to reduce their depth buffer range)
            orion.scale.set(10, 10, 10);

            // Displace objects along their local axes
            spaceStationV.position.set(spaceStationVDistance, 0, 0);
            orion.position.set(-orionDistance, 0, 0);

            // Apply the custom outline to the visual objects
            spaceStationV.traverse(node => node.applyOutline = true);
            orion.traverse(node => node.applyOutline = true);

            // Add the groups to their respective scenes
            scene.add(group);

            // Take note of some common variables for ease of use during updates
            orionStartPosition = orion.position.x;
            areModelsLoaded = true;
        });


        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        effect = new AsciiEffect( renderer, ' .:-+*=%@#', { invert: true, resolution: 0.15 } );
        effect.setSize( window.innerWidth, window.innerHeight );
        effect.domElement.style.color = 'orange';
        effect.domElement.style.backgroundColor = 'black';

        // Special case: append effect.domElement, instead of renderer.domElement.
        // AsciiEffect creates a custom domElement (a div container) where the ASCII elements are placed.

        document.body.appendChild( effect.domElement );

        controls = new TrackballControls( camera, effect.domElement );

        //

        window.addEventListener( 'resize', onWindowResize );

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
        effect.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function animate() {

        requestAnimationFrame( animate );

        render();

    }

    function render() {

        const timer = Date.now() - start;

        controls.update();

        effect.render( scene, camera );

    }

</script>

</body>
</html>